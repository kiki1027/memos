#

## ❗️❗️用「堆」实现一定要注意一个重点

1. 如果是自上往下，那么方向是左右子树中选一个  
2. 如果是自下往上，那么方向只有一个，就是父节点  

### 怎么理解插入

当插入新元素时，我们采用自下往上，拿最新的节点(也就是当前数组插入的最后一个节点)一层层和父节点比较，若不符合条件时就将值交换，再不断往上层父节点比。

所以当我们在堆中追加一个元素，我们需要逐级向上和父节点进行比较，找到我们最终放在哪个位置，那么每插入一个节点所需的时间复杂度就由二叉树的深度决定了，二叉树的深度为logn，插入n个节点则需要O(nlogn)。

### 怎么理解删除

当删除元素(根节点)后，我们采用自上往下的方式，每次都拿当前节点和左、右子节点分别比较，选择更符合条件的子节点进行交换和继续向下。

## 重中之重

这里提醒一下，不知道有没有同学会在想“为什么每次都是单侧树的方向，不会比漏么？”

一开始我也纠结过这个问题，其实有一个很好理解的方式，就是一个「合格的堆」的特征是<**每个节点**的值大于等于或小于等于它的左右子节点> 这说明了什么？

这说明了这个特征的范围其实说白了就是以**当前节点为根节点**的最小树，**至多至多至多**就是三个节点！和它爸爸的爸爸、爸爸的兄弟、儿子的儿子、儿子的兄弟都没有关系。那么再说回来，我们每次的逐级比较，都是以当前这个节点为中心，只和当前节点的爸爸或儿子比较，只要找到了能形成「堆特征」那个小子树，就是我们可以放置的位置，就不用再往后找了
