/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
  let res = 0;
  let l = 0;
  let r = 0;

  /**
   * 左右双指针，圈出当前可到达的区间范围
   * r不能包括终点，因为计算的是当前区间到达终点需要的步数
   * 如果区间包含终点，就不对了
   */
  while (r < nums.length - 1) {
    // 因为本题只求步数，所以我们每次都找到当前可以走到的最远位置
    let farthest = 0;
    /**
     * 这里要怎么理解区间？
     * 首先，双指针一开始都放在0位置，我们取到0位置的步长后，得到从0位置可以到达的最远位置farthest
     * 我们打个比方 如果farthest=4，那么相当于0位置后的4个位置都是在一次跳跃中可以到达的（跳1步或2步或3步或4步）
     * 我们就可以锁定这4个位置作为下一个查找区间
     * 那么下一个查找区间也是，我们锁定了的4个位置，分别比较得出从这四个位置能一步跳到的最远位置
     * 就像这样反复锁定区间，每跨一个区间，相当于这是一次跳跃内可以实现的 给次数+1
     *
     * 这种方式的前提是题目写明了从起点一定是可以到达终点的，没有空的步长
     * 所以我们不用关心每一步具体是怎么跳跃的，只需要关心跳多少回
     */
    for (let i = l; i <= r; i++) {
      // 能走的步数由当前位置上的步长决定
      farthest = Math.max(farthest, i + nums[i]);
      res++;
    }

    /**
     * <更新下一个区间>
     * [下一个区间的范围] 右指针为我们找到的最远位置 左指针为上一个区间右指针的下一位
     */
    l = r + 1;
    r = farthest;
  }

  return res;
};

jump([2, 3, 1, 1, 4]);
