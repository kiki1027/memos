/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function (grid) {
  const row = grid.length;
  const col = grid[0].length;

  /**
   * 因为我们求的是路径最小值
   * 我们能确定的是，每个格子只有两条路能走
   * 求路径最小值的话，那很显然我们选较小的那一条路走
   * 那么就有个问题，从起点出发，
   * 我们只能知道当前格子要去的两个方向的大小，
   * 但未来要走的格子大小我们并不确定，
   *
   * 所以我们采取倒着走，从终点倒过来选择，
   * 从确定的到不确定的，
   * 对于一个格子和它的上一个格子来说，
   * 谁走到它的路径和最小就是确定的，
   * 在走来的两个格子里选择一个较小的倒着走，
   * 直到倒回到[0,0]为止，便是结果
   *
   * 直接原地修改数组可以省去空间及去重操作
   */

  /**
   * 最后一行逐行往上 r--
   * 最后一列逐列往左 c--
   */
  for (let r = row - 1; r >= 0; r--) {
    for (let c = col - 1; c >= 0; c--) {
      if (r === row - 1 && c === col - 1) {
        // 避开终点格子，终点格子路径和为自身
        continue;
      }
      /**
       * 边界情况：
       * 1. 最后一列没有right
       * 2. 最后一行没有down
       * <没有 right/down 和 right=0/down=0 是不一样的>
       * 这会影响我们判断真实路径和，我们单独处理
       */
      if (r === row - 1) {
        // 最后一行，只有向右一条路
        grid[r][c] = grid[r][c] + grid[r][c + 1];
      } else if (c === col - 1) {
        // 最后一列，只有向下一条路
        grid[r][c] = grid[r][c] + grid[r + 1][c];
      } else {
        grid[r][c] = Math.min(
          grid[r][c] + grid[r][c + 1],
          grid[r][c] + grid[r + 1][c]
        );
      }
    }
  }

  return grid[0][0];
};

console.log(
  minPathSum([
    [9, 9, 0, 8, 9, 0, 5, 7, 2, 2, 7, 0, 8, 0, 2, 4, 8],
    [4, 4, 2, 7, 6, 0, 9, 7, 3, 2, 5, 4, 6, 5, 4, 8, 7],
    [4, 9, 7, 0, 7, 9, 2, 4, 0, 2, 4, 4, 6, 2, 8, 0, 7],
    [7, 7, 9, 6, 6, 4, 8, 4, 8, 7, 9, 4, 7, 6, 9, 6, 5],
    [1, 3, 7, 5, 7, 9, 7, 3, 3, 3, 8, 3, 6, 5, 0, 3, 6],
    [7, 1, 0, 7, 5, 0, 6, 6, 5, 3, 2, 6, 0, 0, 9, 5, 7],
    [6, 5, 6, 3, 8, 1, 8, 6, 4, 4, 3, 4, 9, 9, 3, 3, 1],
    [1, 0, 2, 9, 7, 9, 3, 1, 7, 5, 1, 8, 2, 8, 4, 7, 6],
    [9, 6, 7, 7, 4, 1, 4, 0, 6, 5, 1, 9, 0, 3, 2, 1, 7],
    [2, 0, 8, 7, 1, 7, 4, 3, 5, 6, 1, 9, 4, 0, 0, 2, 7],
    [9, 8, 1, 3, 8, 7, 1, 2, 8, 3, 7, 3, 4, 6, 7, 6, 6],
    [4, 8, 3, 8, 1, 0, 4, 4, 1, 0, 4, 1, 4, 4, 0, 3, 5],
    [6, 3, 4, 7, 5, 4, 2, 2, 7, 9, 8, 4, 5, 6, 0, 3, 9],
    [0, 4, 9, 7, 1, 0, 7, 7, 3, 2, 1, 4, 7, 6, 0, 0, 0],
  ])
);
